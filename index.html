<!DOCTYPE html>
<html>
<head>
    <title>Basic Raytracing Demo - Multiple Objects with Lighting</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Load gl-matrix -->
    <script src="https://unpkg.com/gl-matrix@3.4.3/gl-matrix-min.js"></script>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
        body {
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        #error {
            color: red;
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <div id="error"></div>
    
    <!-- All code in a single script tag -->
    <script>
        // Check if gl-matrix is loaded
        if (typeof glMatrix === 'undefined') {
            document.getElementById('error').textContent = 'Error: gl-matrix library not loaded!';
            throw new Error('gl-matrix not loaded');
        }

        /************** HELPER.JS CODE ****************/
        // Vector and Matrix operations using gl-matrix
        const vec3 = glMatrix.vec3;
        const mat4 = glMatrix.mat4;

        // Vector operations
        function add(a, b) {
            return vec3.add(vec3.create(), a, b);
        }

        function subtract(a, b) {
            return vec3.subtract(vec3.create(), a, b);
        }

        function scale(v, s) {
            return vec3.scale(vec3.create(), v, s);
        }

        function normalize(v) {
            return vec3.normalize(vec3.create(), v);
        }

        function dot(a, b) {
            return vec3.dot(a, b);
        }

        function length(v) {
            return vec3.length(v);
        }

        // Ray structure
        class Ray {
            constructor(origin, direction) {
                this.origin = origin;
                this.direction = direction;
            }
        }

        // Sphere structure
        class Sphere {
            constructor(center, radius, material) {
                if (!center || !radius) {
                    throw new Error('Sphere requires center and radius');
                }
                this.center = center;
                this.radius = radius;
                this.material = material;
            }

            // Calculate normal at intersection point
            getNormal(intersectionPoint) {
                if (!intersectionPoint) {
                    throw new Error('Intersection point is required');
                }
                return normalize(subtract(intersectionPoint, this.center));
            }

            // Calculate intersection point
            getIntersectionPoint(ray, t) {
                if (!ray || t === undefined) {
                    throw new Error('Ray and t parameter are required');
                }
                return add(ray.origin, scale(ray.direction, t));
            }
        }

        // Ray-Sphere intersection
        function intersectRaySphere(ray, sphere) {
            if (!ray || !sphere) {
                throw new Error('Ray and sphere are required');
            }
            
            const oc = subtract(ray.origin, sphere.center);
            const a = dot(ray.direction, ray.direction);
            const b = 2.0 * dot(oc, ray.direction);
            const c = dot(oc, oc) - sphere.radius * sphere.radius;
            const discriminant = b * b - 4 * a * c;

            if (discriminant < 0) {
                return -1; // No intersection
            }

            const t = (-b - Math.sqrt(discriminant)) / (2.0 * a);
            return t;
        }

        // Find closest intersection among multiple spheres
        function findClosestIntersection(ray, spheres) {
            if (!ray || !spheres || !Array.isArray(spheres)) {
                throw new Error('Ray and spheres array are required');
            }

            let closestT = Infinity;
            let closestSphere = null;
            let intersectionPoint = null;

            for (const sphere of spheres) {
                const t = intersectRaySphere(ray, sphere);
                if (t > 0 && t < closestT) {
                    closestT = t;
                    closestSphere = sphere;
                    intersectionPoint = sphere.getIntersectionPoint(ray, t);
                }
            }

            return { 
                t: closestT, 
                sphere: closestSphere,
                point: intersectionPoint
            };
        }

        /************** LIGHTING.JS CODE ****************/
        // Material properties
        class Material {
            constructor(ambient, diffuse, specular, shininess) {
                if (!ambient || !diffuse || !specular) {
                    throw new Error('Material requires ambient, diffuse, and specular properties');
                }
                this.ambient = ambient;
                this.diffuse = diffuse;
                this.specular = specular;
                this.shininess = shininess || 32.0;
            }
        }

        // Light properties
        class Light {
            constructor(position, ambient, diffuse, specular) {
                if (!position) {
                    throw new Error('Light requires position');
                }
                this.position = position;
                this.ambient = ambient || { r: 0.2, g: 0.2, b: 0.2 };
                this.diffuse = diffuse || { r: 0.8, g: 0.8, b: 0.8 };
                this.specular = specular || { r: 1.0, g: 1.0, b: 1.0 };
            }
        }

        // Calculate ambient component
        function calculateAmbient(material, light) {
            if (!material || !light) {
                throw new Error('Material and light are required for ambient calculation');
            }
            return {
                r: material.ambient.r * light.ambient.r,
                g: material.ambient.g * light.ambient.g,
                b: material.ambient.b * light.ambient.b
            };
        }

        // Calculate diffuse component
        function calculateDiffuse(material, light, normal, lightDir) {
            if (!material || !light || !normal || !lightDir) {
                throw new Error('All parameters are required for diffuse calculation');
            }
            const dotProduct = Math.max(dot(normal, lightDir), 0);
            return {
                r: material.diffuse.r * light.diffuse.r * dotProduct,
                g: material.diffuse.g * light.diffuse.g * dotProduct,
                b: material.diffuse.b * light.diffuse.b * dotProduct
            };
        }

        // Calculate reflection vector
        function reflect(incident, normal) {
            if (!incident || !normal) {
                throw new Error('Incident and normal vectors are required');
            }
            const dotProduct = dot(incident, normal);
            return subtract(scale(normal, 2 * dotProduct), incident);
        }

        // Calculate specular component
        function calculateSpecular(material, light, normal, lightDir, viewDir) {
            if (!material || !light || !normal || !lightDir || !viewDir) {
                throw new Error('All parameters are required for specular calculation');
            }
            const reflectDir = reflect(lightDir, normal);
            const spec = Math.pow(Math.max(dot(viewDir, reflectDir), 0), material.shininess);
            return {
                r: material.specular.r * light.specular.r * spec,
                g: material.specular.g * light.specular.g * spec,
                b: material.specular.b * light.specular.b * spec
            };
        }

        // Calculate final color using Phong model
        function calculatePhongColor(material, light, normal, lightDir, viewDir) {
            if (!material || !light || !normal || !lightDir || !viewDir) {
                throw new Error('All parameters are required for Phong calculation');
            }
            const ambient = calculateAmbient(material, light);
            const diffuse = calculateDiffuse(material, light, normal, lightDir);
            const specular = calculateSpecular(material, light, normal, lightDir, viewDir);

            return {
                r: Math.min(ambient.r + diffuse.r + specular.r, 1.0),
                g: Math.min(ambient.g + diffuse.g + specular.g, 1.0),
                b: Math.min(ambient.b + diffuse.b + specular.b, 1.0)
            };
        }

        /************** MAIN CODE ****************/
        // Initialize and render
        function init() {
            try {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                // Create light
                const light = new Light(
                    vec3.fromValues(2, 2, 0), // light position
                    { r: 0.2, g: 0.2, b: 0.2 }, // ambient
                    { r: 0.8, g: 0.8, b: 0.8 }, // diffuse
                    { r: 1.0, g: 1.0, b: 1.0 }  // specular
                );

                // Create materials for spheres
                const redMaterial = new Material(
                    { r: 0.1, g: 0.0, b: 0.0 },  // ambient
                    { r: 0.7, g: 0.0, b: 0.0 },  // diffuse
                    { r: 0.3, g: 0.3, b: 0.3 },  // specular
                    32.0                         // shininess
                );

                const greenMaterial = new Material(
                    { r: 0.0, g: 0.1, b: 0.0 },  // ambient
                    { r: 0.0, g: 0.7, b: 0.0 },  // diffuse
                    { r: 0.3, g: 0.3, b: 0.3 },  // specular
                    32.0                         // shininess
                );

                const blueMaterial = new Material(
                    { r: 0.0, g: 0.0, b: 0.1 },  // ambient
                    { r: 0.0, g: 0.0, b: 0.7 },  // diffuse
                    { r: 0.3, g: 0.3, b: 0.3 },  // specular
                    32.0                         // shininess
                );

                // Create multiple spheres with overlapping positions
                const spheres = [
                    new Sphere(
                        vec3.fromValues(0, 0, -5), // center
                        1.5, // radius (larger)
                        redMaterial
                    ),
                    new Sphere(
                        vec3.fromValues(-1, 0, -4), // center (closer to camera)
                        1.2, // radius
                        greenMaterial
                    ),
                    new Sphere(
                        vec3.fromValues(1, 0, -6), // center (further from camera)
                        1.2, // radius
                        blueMaterial
                    )
                ];

                // Camera position
                const cameraPos = vec3.fromValues(0, 0, 0);

                // Render the scene
                function render() {
                    console.log("Rendering started...");
                    const imageData = ctx.createImageData(width, height);
                    const data = imageData.data;

                    // For each pixel
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            // Convert pixel coordinates to normalized device coordinates (-1 to 1)
                            const ndcX = (2.0 * x) / width - 1.0;
                            const ndcY = 1.0 - (2.0 * y) / height;

                            // Create ray direction
                            const rayDir = normalize(vec3.fromValues(ndcX, ndcY, -1));
                            const ray = new Ray(cameraPos, rayDir);

                            // Check intersection with all spheres
                            const intersection = findClosestIntersection(ray, spheres);

                            // Calculate pixel index
                            const pixelIndex = (y * width + x) * 4;

                            if (intersection.sphere) {
                                // Calculate lighting
                                const normal = intersection.sphere.getNormal(intersection.point);
                                const lightDir = normalize(subtract(light.position, intersection.point));
                                const viewDir = normalize(subtract(cameraPos, intersection.point));

                                // Calculate final color using Phong model
                                const finalColor = calculatePhongColor(
                                    intersection.sphere.material,
                                    light,
                                    normal,
                                    lightDir,
                                    viewDir
                                );

                                // Convert from 0-1 to 0-255 range
                                data[pixelIndex] = finalColor.r * 255;     // R
                                data[pixelIndex + 1] = finalColor.g * 255; // G
                                data[pixelIndex + 2] = finalColor.b * 255; // B
                                data[pixelIndex + 3] = 255;                // A
                            } else {
                                // If no intersection, color the pixel white
                                data[pixelIndex] = 255;     // R
                                data[pixelIndex + 1] = 255; // G
                                data[pixelIndex + 2] = 255; // B
                                data[pixelIndex + 3] = 255; // A
                            }
                        }
                    }

                    // Put the image data to the canvas
                    ctx.putImageData(imageData, 0, 0);
                    console.log("Rendering completed!");
                }

                // Start rendering
                render();
            } catch (error) {
                document.getElementById('error').textContent = 'Error: ' + error.message;
                console.error('Raytracing error:', error);
            }
        }

        // Start the application when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 